/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three"
import React, { useContext, useEffect, useRef, useState } from "react"
import { useGLTF } from "@react-three/drei"
import { GLTF } from "three-stdlib"
import { Mesh } from "three"
import { ControllerContext } from "../components/ControllerContext"
import { degToRad } from "three/src/math/MathUtils"
import { useFrame } from "@react-three/fiber"
import { GameStateContext } from "../components/GameState"

type GLTFResult = GLTF & {
    nodes: {
        bottom: THREE.Mesh
        top: THREE.Mesh
    }
    materials: {
        BottomMaterial: THREE.MeshPhysicalMaterial
        TopMaterial: THREE.MeshPhysicalMaterial
    }
}

interface GenericLevelModelProps extends LevelModelProps {
    modelPath: string
}

export interface LevelModelProps {
    group?: JSX.IntrinsicElements["group"]
    bottom?: JSX.IntrinsicElements["mesh"]
    top?: JSX.IntrinsicElements["mesh"]
}

export function GenericLevelModel(props: GenericLevelModelProps) {
    const top = useRef<Mesh>(null!)
    const bottom = useRef<Mesh>(null!)

    const controllerContext = useContext(ControllerContext)
    const gameStateContext = useContext(GameStateContext)

    useEffect(() => {
        const [alpha, beta, gamma] = controllerContext.orientation

        if (!gameStateContext.levelComplete) {
            const distraction = gameStateContext.level.rotation

            bottom.current.setRotationFromEuler(distraction || new THREE.Euler(0, 0, 0, "XYZ"))
            bottom.current.rotateY(degToRad(alpha))
            bottom.current.rotateZ(degToRad(beta))
            bottom.current.rotateX(degToRad(gamma))

            top.current.position.set(0, 6, 2)
            top.current.rotation.set(0, Math.PI / 2, 0)
        }
    }, [
        controllerContext.orientation,
        gameStateContext.levelComplete,
        gameStateContext.level.rotation
    ])

    useFrame((_, delta) => {
        if (gameStateContext.levelComplete && top.current.position.y > 1) {
            const factor = (Math.abs(6.1 - top.current.position.y) / 5.2) * Math.PI
            top.current.position.y -= 8 * Math.sin(factor) * delta
        }
        if (gameStateContext.levelComplete && top.current.position.y <= 1) {
            top.current.rotateY(delta / 2)
            bottom.current.rotation.copy(top.current.rotation)
        }
    })

    const { nodes, materials } = useGLTF(props.modelPath) as unknown as GLTFResult
    return (
        <group {...props.group} dispose={null} position={[0, 1, -10]}>
            <mesh
                name="bottom"
                ref={bottom}
                castShadow
                receiveShadow
                position={[0, -3, 2]}
                geometry={nodes.bottom.geometry}
                material={materials.BottomMaterial}
                {...props.bottom}
            />
            <mesh
                name="top"
                ref={top}
                castShadow
                receiveShadow
                geometry={nodes.top.geometry}
                material={materials.TopMaterial}
                rotation={[0, Math.PI / 2, 0]}
                position={[0, 6, 2]}
                {...props.top}
            />
        </group>
    )
}

// useGLTF.preload("/Easy1.gltf")
